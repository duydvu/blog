<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NM1Z2PXXYW"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-NM1Z2PXXYW');
</script>

  
  <title>Blog của tui</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Nơi để mình chia sẻ kiến thức về lập trình, khoa học dữ liệu, AI và nhiều thứ hay ho liên quan đến tech.">
<meta property="og:type" content="website">
<meta property="og:title" content="Blog của tui">
<meta property="og:url" content="http://blogcuatui.online/index.html">
<meta property="og:site_name" content="Blog của tui">
<meta property="og:description" content="Nơi để mình chia sẻ kiến thức về lập trình, khoa học dữ liệu, AI và nhiều thứ hay ho liên quan đến tech.">
<meta property="og:locale" content="vi_VN">
<meta property="article:author" content="Vũ Đức Duy">
<meta property="article:tag" content="lập trình, programming, công nghệ phần mềm, software engineering, AI, trí tuệ nhân tạo, data science, khoa học dữ liệu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Blog của tui" type="application/atom+xml">
  
  
    <link rel="icon" type="image/png" href="/favicon.png">
  
  <link rel="preconnect" href="https://fonts.gstatic.com">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css2?family=Fira+Sans:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo">
        Blog của tui
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Nơi để mình chia sẻ kiến thức về lập trình, khoa học dữ liệu, AI và nhiều thứ hay ho liên quan đến tech.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Trang chủ</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Tìm kiếm"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blogcuatui.online"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Lam-quen-voi-Kafka-Phan-1-Chat-voi-nhau-tren-console" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/01/Lam-quen-voi-Kafka-Phan-1-Chat-voi-nhau-tren-console/" class="article-date">
  <time datetime="2021-01-01T18:18:04.000Z" itemprop="datePublished">2021-01-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/01/Lam-quen-voi-Kafka-Phan-1-Chat-voi-nhau-tren-console/">Làm quen với Kafka: Phần 1 - Chat với nhau trên console</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Trong 1 hệ thống theo kiến trúc Microservice, để xử lý 1 khối lượng dữ liệu lớn với sự tác động của nhiều service khác nhau, ta phải có cơ chế để các service này giao tiếp với nhau một cách hiệu quả, Kafka được sinh ra để làm nhiệm vụ đó. Trong phần đầu tiên của series “Làm quen với Kafka”, mình sẽ viết 1 ứng dụng Python dùng để chat với nhau trên màn hình console để hiểu được những tính năng cơ bản của Kafka.</p>
<p>Lưu ý đây chỉ là 1 ứng dụng làm cho vui để làm quen với Kafka thôi chứ không nên đưa vào thực tế nhé.</p>
<h1 id="Truoc-het-Kafka-la-gi"><a href="#Truoc-het-Kafka-la-gi" class="headerlink" title="Trước hết, Kafka là gì?"></a>Trước hết, Kafka là gì?</h1><p>Kafka là 1 nền tảng event streaming rất phổ biến hiện nay được phát triển bởi tổ chức Apache và là một phần mềm mã nguồn mở. Event streaming ở đây có nghĩa là việc lấy dữ liệu theo thời gian thực từ những nguồn như là cơ sở dữ liệu, cảm biến, thiết bị di động, dịch vụ đám mây và ứng dụng dưới dạng những luồng sự kiện; lưu những sự kiện này để sau đó có thể lấy lên lại và xử lý.</p>
<h2 id="Nghe-phuc-tap-qua-Tim-1-vi-du-cho-de-hieu-nao"><a href="#Nghe-phuc-tap-qua-Tim-1-vi-du-cho-de-hieu-nao" class="headerlink" title="Nghe phức tạp quá. Tìm 1 ví dụ cho dễ hiểu nào!"></a>Nghe phức tạp quá. Tìm 1 ví dụ cho dễ hiểu nào!</h2><p>Tưởng tượng bạn đang xem kênh Discovery trên TV của bạn. Những hình ảnh và âm thanh mà bạn thấy và nghe được đều được phát đi từ đài truyền hình của kênh này. Ở đây, đài truyền hình của kênh Discovery đóng vai trò là <strong>publisher</strong>, còn bạn - người xem là <strong>subscriber</strong> và kênh Discovery chính là <strong>topic</strong>.</p>
<p>Publisher có nhiệm vụ là phát đi thông tin vào 1 topic (kênh), thông tin trong trường hợp này là dữ liệu ở dạng hình ảnh và âm thanh. Subscriber có thể đăng ký để lắng nghe trên 1 topic (chọn kênh để xem) và nhận được thông tin mà publisher phát đi. Subscriber cũng có thể lắng nghe trên nhiều topic (xem nhiều kênh trên nhiều TV, nếu bạn giàu và rảnh :D).</p>
<p>Đối với publisher, việc ai nhận được thông tin không quan trọng, miễn là cứ có thông tin thì nó sẽ phát đi vào 1 hoặc nhiều topic cụ thể. Còn đối với subscriber, publisher nào phát không quan trọng, miễn là topic đó có thông tin thì cứ lấy ra mà xử lý.</p>
<h1 id="Viet-ung-dung-chat-tren-console"><a href="#Viet-ung-dung-chat-tren-console" class="headerlink" title="Viết ứng dụng chat trên console"></a>Viết ứng dụng chat trên console</h1><p>Kafka hoạt động theo cơ chế client-server, trong đó, server là 1 process chạy trên 1 máy tính và client có thể kết nối đến nó giống như cách bạn kết nối đến database, sử dụng địa chỉ IP và port cùng với username và password nếu có. Client có thể là publisher, consumer hoặc là admin.</p>
<p>Việc đầu tiên bạn cần phải làm đó là khởi động Kafka server trên 1 chiếc máy tính.</p>
<h2 id="Khoi-dong-Kafka-server"><a href="#Khoi-dong-Kafka-server" class="headerlink" title="Khởi động Kafka server"></a>Khởi động Kafka server</h2><ol>
<li><strong>Bước 1</strong>: Mở terminal lên vào nhập dòng lệnh sau để tải Kafka:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Downloads</span><br><span class="line">wget https://downloads.apache.org/kafka/2.7.0/kafka_2.13-2.7.0.tgz</span><br></pre></td></tr></table></figure></li>
<li><strong>Bước 2</strong>: Giải nén file vừa tải về:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf kafka_2.13-2.7.0.tgz</span><br><span class="line"><span class="built_in">cd</span> kafka_2.13-2.7.0</span><br></pre></td></tr></table></figure></li>
<li><strong>Bước 3</strong>: Khởi động ZooKeeper service:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/zookeeper-server-start.sh config/zookeeper.properties</span><br></pre></td></tr></table></figure></li>
<li><strong>Bước 4</strong>: Mở 1 terminal mới và nhập dòng lệnh sau đây để bắt đầu chạy Kafka server:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Co-che-hoat-dong"><a href="#Co-che-hoat-dong" class="headerlink" title="Cơ chế hoạt động"></a>Cơ chế hoạt động</h2><p>Trước khi bắt tay vào viết ứng dụng này, mình sẽ nói 1 chút về cách nó hoạt động như sau:</p>
<ul>
<li>Mỗi user khi được tạo sẽ được cấp cho 1 định danh duy nhất, ở đây mình dùng tên của user cho đơn giản. Mỗi user cũng sẽ được cấp 1 topic duy nhất mang tên của chính user đó. Ví dụ: user có tên là user1 sẽ được cấp cho topic cũng tên là user1.</li>
<li>Mỗi user luôn subscribe vào topic của chính họ, và publish vào topic của các user khác.</li>
<li>Giả sử user A và user B đang chat với nhau, user A muốn gửi tin nhắn cho B thì sẽ publish nội dung tin nhắn vào topic B, sau đó user B đang subscribe trên topic của mình sẽ nhận được tin nhắn từ A, quá trình nhắn tin từ B tới A cũng diễn ra tương tụ.</li>
</ul>
<p><img src="/2021/01/01/Lam-quen-voi-Kafka-Phan-1-Chat-voi-nhau-tren-console/kafka-message.svg" alt="Minh họa cách thức giao tiếp giữa 2 user A và B"></p>
<h2 id="Code-nao"><a href="#Code-nao" class="headerlink" title="Code nào"></a>Code nào</h2><p>Để có thể giao tiếp được với Kafka server, bạn cần dùng thư viện kafka-python. Sử dụng pip để cài đặt thư viện này:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install kafka-python</span><br></pre></td></tr></table></figure>
<p>Bạn có thể đọc document của thư viện này tại <a target="_blank" rel="noopener" href="https://kafka-python.readthedocs.io/en/master/usage.html">đây</a>.</p>
<p>Trước tiên, mình thử publish vào 1 topic bằng đoạn code sau:</p>
<figure class="highlight python"><figcaption><span>publisher.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaProducer</span><br><span class="line"></span><br><span class="line">BOOTSTRAP_SERVERS = [<span class="string">&#x27;localhost:9092&#x27;</span>]</span><br><span class="line">producer = KafkaProducer(bootstrap_servers=BOOTSTRAP_SERVERS,</span><br><span class="line">                         value_serializer=<span class="keyword">lambda</span> value: <span class="built_in">bytes</span>(value, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">username1 = <span class="built_in">input</span>(<span class="string">&#x27;What is your name? &#x27;</span>)</span><br><span class="line">username2 = <span class="built_in">input</span>(<span class="string">&#x27;Who do want connect? &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    value = <span class="built_in">input</span>()</span><br><span class="line">    producer.send(username2, value=value)</span><br><span class="line">    producer.flush()</span><br></pre></td></tr></table></figure>

<p>Đoạn code này sẽ hỏi tên của bạn và tên của user mà bạn muốn nhắn tin, sau đó nó bắt đầu 1 vòng lặp forever để chờ bạn nhập tin nhắn và gửi tin nhắn đó đến topic của user kia.</p>
<p><code>BOOTSTRAP_SERVERS</code> chứa thông tin để kết nối đến server Kafka mà mình vừa khởi động ở trên, vì mình chạy Kafka trên máy của mình nên địa chỉ IP của server Kafka là localhost và port mặc định là 9092.</p>
<p>Một message trong Kafka có 2 trường: <code>key</code> và <code>value</code>. Bạn có thể truyền bất cứ dữ liệu nào vào trong 2 trường này. Ở đây mình chỉ cần gửi nội dung tin nhắn nên dùng trường <code>value</code> là đủ.</p>
<p>Dữ liệu trong 1 message phải có dạng <code>byte</code>. Vậy nên trước khi gửi mình phải chuyển tin nhắn từ dạng <code>string</code> sang <code>byte</code> bằng cách truyền tham số <code>value_serializer</code> cho 1 hàm lambda.</p>
<p>Test script này bằng lệnh trong terminal:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python publisher.py</span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/01/Lam-quen-voi-Kafka-Phan-1-Chat-voi-nhau-tren-console/Screenshot-2021-01-01-160825.png" alt="Chạy thử script chat.py với tên là user1 và user2"></p>
<p>Vì mình mới chỉ chạy ở bên phía user1 nên không có bất cứ phản hồi nào từ user2. Giờ mình sẽ viết code để user2 lắng nghe tin nhắn từ user1:</p>
<figure class="highlight python"><figcaption><span>subscriber.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaConsumer</span><br><span class="line"></span><br><span class="line">BOOTSTRAP_SERVERS = [<span class="string">&#x27;localhost:9092&#x27;</span>]</span><br><span class="line">username2 = <span class="built_in">input</span>(<span class="string">&#x27;What is your name? &#x27;</span>)</span><br><span class="line"></span><br><span class="line">consumer = KafkaConsumer(username2, auto_offset_reset=<span class="string">&#x27;latest&#x27;</span>,</span><br><span class="line">                         bootstrap_servers=BOOTSTRAP_SERVERS,</span><br><span class="line">                         value_deserializer=<span class="keyword">lambda</span> value: value.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> msg <span class="keyword">in</span> consumer:</span><br><span class="line">    print(msg.value)</span><br></pre></td></tr></table></figure>
<p>Đoạn code trên khởi tạo 1 instance <code>KafkaConsumer</code> để subscribe vào topic của user2 và bắt đầu 1 vòng lặp for để lắng nghe trên topic này. Vòng lặp for này sẽ chờ message từ topic trong thời gian vô hạn và không bao giờ dừng lại trừ khi bạn dừng chương trình.</p>
<p>Tham số <code>value_deserializer</code> là 1 hàm được dùng khi consumer nhận được message từ topic để chuyển trường <code>value</code> của message từ dạng <code>byte</code> trở về dạng ban đầu của nó, trong trường hợp này là <code>string</code>.</p>
<p>Để chạy script này, mở một tab terminal mới và chạy lệnh:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python subscriber.py</span><br></pre></td></tr></table></figure>

<p>Nhập tên user2 để bắt đầu lắng nghe.</p>
<p>Quay lại tab đang chạy publisher, thử nhập 1 message bất kỳ và quay lại tab đang chạy subscriber. Bạn sẽ thấy message mà mình vừa nhập hiện trên terminal của subscriber.</p>
<p><img src="/2021/01/01/Lam-quen-voi-Kafka-Phan-1-Chat-voi-nhau-tren-console/Screenshot-2021-01-01-161638.png" alt="Chạy thử script chat.py với tên là user1 và user2"></p>
<p>Như vậy là chúng ta đã thiết lập được giao tiếp 1 chiều giữa 2 user. Tiếp theo, mình sẽ làm cho mỗi user vừa publish vừa subscribe vào Kafka để có thể vừa gửi và nhập tin nhắn.</p>
<p>Như bạn thấy trong 2 đoạn code trên, cả 2 đều chứa 1 vòng lặp vô hạn. Điều này có nghĩa là khi user đang gửi tin nhắn thì không thể nhận tin nhắn và ngược lại, vì bản chất của 2 đoạn code trên là blocking - chương trình sẽ chờ trong vô hạn để hoàn thành 1 tác vụ rồi mới chuyển sang tác vụ kế tiếp.</p>
<p>Để giải quyết vấn đề này, mình sẽ sử dụng thread để tạo 1 thread chạy song song với thread chính. Thread chính có nhiệm vụ là gửi tin nhắn cho đối phương còn thread được tạo có nhiệm vụ nhận tin nhắn từ đối phương.</p>
<p>Trong Python, để làm việc với thread, mình sử dụng thư viện threading có sẵn. Cách sử dụng khá đơn giản, chỉ cần khởi tạo 1 instance <code>Thread</code> với 2 tham số: <code>target</code> là hàm sẽ chạy trong thread mới; và <code>args</code> là tham số truyền vào hàm <code>target</code>. Sau đó gọi method <code>start</code>. Ví dụ:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread = threading.Thread(target=foo, args=())</span><br><span class="line">thread.start()</span><br></pre></td></tr></table></figure>

<p>Vậy trước khi bắt đầu vòng lặp while trong publisher, mình chỉ cần tạo 1 thread mới chạy hàm của subscriber là xong. Dưới đây là đoạn code hoàn chỉnh của chương trình:</p>
<figure class="highlight python"><figcaption><span>chat.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaConsumer, KafkaProducer</span><br><span class="line"></span><br><span class="line">BOOTSTRAP_SERVERS = [<span class="string">&#x27;localhost:9092&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subscribe</span>(<span class="params">topic</span>):</span></span><br><span class="line">    consumer = KafkaConsumer(topic, auto_offset_reset=<span class="string">&#x27;latest&#x27;</span>,</span><br><span class="line">                             bootstrap_servers=BOOTSTRAP_SERVERS,</span><br><span class="line">                             value_deserializer=<span class="keyword">lambda</span> value: value.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="keyword">for</span> msg <span class="keyword">in</span> consumer:</span><br><span class="line">        print(msg.value)</span><br><span class="line"></span><br><span class="line">username1 = <span class="built_in">input</span>(<span class="string">&#x27;What is your name? &#x27;</span>)</span><br><span class="line">username2 = <span class="built_in">input</span>(<span class="string">&#x27;Who do want connect? &#x27;</span>)</span><br><span class="line"></span><br><span class="line">consumer_thread = threading.Thread(target=subscribe, args=(username2,))</span><br><span class="line">consumer_thread.start()</span><br><span class="line"></span><br><span class="line">producer = KafkaProducer(bootstrap_servers=BOOTSTRAP_SERVERS,</span><br><span class="line">                         value_serializer=<span class="keyword">lambda</span> value: <span class="built_in">bytes</span>(value, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    key = username1</span><br><span class="line">    value = <span class="built_in">input</span>()</span><br><span class="line">    producer.send(username1, value=value)</span><br><span class="line">    producer.flush()</span><br></pre></td></tr></table></figure>

<p>Bạn thử mở 2 tab terminal, cho mỗi terminal chạy script này. Tab 1 nhập lần lượt user1 và user2, tab 2 nhập ngược lại user2 và user1.</p>
<p>Khi bạn nhập 1 tin nhắn ở tab 1 và nhấn Enter thì tin nhắn đó sẽ được hiện trên tab 2, điều tương tự cũng diễn ra khi bạn nhập vào tab 2.</p>
<p>Như vậy là chúng ta đã hoàn thành xong 1 ứng dụng đơn giản để chat trên console bằng Python và Kafka. Mặc dù vậy, nó vần còn thiếu nhiều tính năng quan trọng như:</p>
<ul>
<li>Chỉ cho 2 user nhắn tin với nhau trong 1 phiên riêng biệt. Hiện tại, nếu có nhiều hơn 2 user thì sẽ có trường hợp 1 user cùng nhắn tin với 2 user khác.</li>
<li>Chỉ cho phép user này nhắn tin với user kia khi được họ cho phép.</li>
</ul>
<p>Mình sẽ thực hiện những tính năng này trong phần 2 của series.</p>
<p>Happy Coding!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blogcuatui.online/2021/01/01/Lam-quen-voi-Kafka-Phan-1-Chat-voi-nhau-tren-console/" data-id="ckje6sj2q00038cnh2z2d65t5" class="article-share-link">Chia sẻ</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Coding/" rel="tag">Coding</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cau-hinh-VS-Code-de-code-tren-server" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/26/Cau-hinh-VS-Code-de-code-tren-server/" class="article-date">
  <time datetime="2020-12-26T11:18:29.000Z" itemprop="datePublished">2020-12-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/26/Cau-hinh-VS-Code-de-code-tren-server/">Cấu hình VS Code để lập trình trên server bằng Remote - SSH</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Trong bài viết này, mình sẽ hướng dẫn cho các bạn cách thiết lập môi trường lập trình trên server hơn thông qua extension Remote - SSH của VS Code.</p>
<p>Trước khi bắt đầu, mình sẽ trả lời cho câu hỏi:</p>
<h1 id="Tai-sao-phai-lap-trinh-tren-server"><a href="#Tai-sao-phai-lap-trinh-tren-server" class="headerlink" title="Tại sao phải lập trình trên server?"></a>Tại sao phải lập trình trên server?</h1><p>Đối với đa số lập trình viên, 1 chiếc laptop hoặc PC là đủ để phục vụ cho công việc của họ. Tuy nhiên, đối với Data Scientist thì đôi khi làm việc trên 1 thiết bị là chưa đủ. Bạn cần phải làm việc trên máy tính có cấu hình mạnh, bộ nhớ lớn để có thể load dữ liệu và huấn luyện mô hình, đặc biệt là các mô hình Deep Learning yêu cầu phải có 1 hoặc nhiều GPU và thời gian huấn luyện có khi lên tới hàng tuần. Những chiếc máy tính mạnh mẽ như vậy thường sẽ không vừa vặn với 1 chiếc laptop hoặc PC nên nếu làm việc trực tiếp thì sẽ khá khó khăn. Vì vậy, việc lập trình trên server sẽ giúp ích rất nhiều, ví dụ như:</p>
<ul>
<li>Bạn có thể huấn luyện mô hình mà vẫn có thể tắt laptop mang đi nơi khác.</li>
<li>Bạn có thể ra quán coffee với chiếc máy tính mỏng nhẹ mà vẫn làm việc được trên chiếc máy tính khủng.</li>
<li>Bạn có thể chia sẻ máy với đồng nghiệp để cùng tận dụng tài nguyên của máy.</li>
</ul>
<p>Hơn nữa, các dịch vụ điện toán đám mây như là AWS, GCP cung cấp dịch vụ tính toán giúp cho chúng ta có thể làm việc trên những chiếc máy tính mạnh mà không cần phải bỏ 1 số tiền lớn để mua hoặc thuê về, điều này cũng khiến cho việc lập trình trên server ngày càng trở nên phổ biến.</p>
<p>Có nhiều cách khác nhau để có thể lập trình được trên server, cách nhanh nhất là bật 1 trình soạn thảo văn bản như Vim hoặc Nano rồi bắt đầu code. Tuy nhiên, những trình soạn thảo này không cung cấp sẵn những tính năng hữu ích của 1 IDE như là syntax highlighting, autocompletion, debugger. Vim là 1 trình soạn thảo rất tuyệt vời vì nó cho phép gắn thêm plugin vào để thêm tính năng, nó cho phép bạn biến nó thành 1 IDE thực thụ thông qua việc cài đặt những plugin được cung cấp bởi rất nhiều lập trình viên khác. Tùy vào sở thích mà bạn có thể chọn Vim là công cụ chính cho việc lập trình trên server, mặc dù việc thao tác trên Vim khá phức tạp nhưng khi bạn đã quen với việc sử dụng nó rồi thì bạn sẽ thấy được sự mạnh mẽ và hiệu quả mà nó đem lại. Mình cũng hay sử dụng Vim cho những tác vụ edit đơn giản trên server vì nó rất nhanh và tiện lợi. Tạm gác Vim qua một bên, trong bài này mình sẽ chỉ tập trung vào cách cấu hình để bạn có thể lập trình trên server thông qua trình soạn thảo VS Code nổi tiếng của Microsoft (nếu bạn đã từng dùng Visual Studio rồi thì nên tránh nhầm lẫn nhé vì đây là 2 phần mềm khác nhau, Visual Studio là 1 IDE còn VS Code chỉ là 1 trình soạn thảo văn bản mà thôi!).</p>
<p>Bắt đầu nào!</p>
<h1 id="Cai-dat-extension-Remote-SSH"><a href="#Cai-dat-extension-Remote-SSH" class="headerlink" title="Cài đặt extension Remote - SSH"></a>Cài đặt extension Remote - SSH</h1><p>Mình giả định rằng bạn đã cài đặt sẵn VS Code trong máy rồi nên mình sẽ chỉ hướng dẫn sau khi bạn đã bật VS Code lên nhé.</p>
<p>Để cài đặt extension trên VS Code, bạn hãy nhấn vào biểu tượng <strong>Extensions</strong> ở thanh công cụ bên trái, sau đó, trên thanh tìm kiếm gõ cụm từ <em>“Remote - SSH”</em>.</p>
<p>Extension mà ta cần tìm sẽ xuất hiện trong kết quả tìm kiếm, nhấn vào đó rồi nhấn nút <strong>Install</strong> để bắt đầu quá trình cài đặt. Sau khi cài đặt xong, khởi động lại VS Code để load extension lên.</p>
<p><img src="/2020/12/26/Cau-hinh-VS-Code-de-code-tren-server/Screenshot-2020-12-26-120808.png" alt="Giao diện VS Code sau khi hoàn tất cài đặt Remote - SSH"></p>
<p>Tiếp theo, mình sẽ hướng dẫn cách cấu hình môi trường lập trình trên server.</p>
<h1 id="Cau-hinh-moi-truong-lap-trinh-tren-server"><a href="#Cau-hinh-moi-truong-lap-trinh-tren-server" class="headerlink" title="Cấu hình môi trường lập trình trên server"></a>Cấu hình môi trường lập trình trên server</h1><h2 id="Buoc-1-Tao-SSH-key"><a href="#Buoc-1-Tao-SSH-key" class="headerlink" title="Bước 1: Tạo SSH key"></a>Bước 1: Tạo SSH key</h2><p>Trước khi kết nối đến server thông qua VS Code, bạn cần phải tạo 1 SSH key để xác thực quyền kết nối của máy bạn với server mà không cần dùng mật khẩu.<br>Nếu bạn đã cấu hình SSH server bằng SSH key rồi thì hãy đến với <a href="#Buoc-3-Thiet-lap-moi-truong-SSH-tren-VS-Code">bước 3</a>.</p>
<p>Mở 1 terminal mới và nhập lệnh sau:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -f ~&#x2F;.ssh&#x2F;id_rsa</span><br></pre></td></tr></table></figure>
<p>Câu lệnh trên sẽ trả về kết quả như dưới đây:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Generating public&#x2F;private rsa key pair.</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br></pre></td></tr></table></figure>
<p>Nhấn Enter 2 lần để hoàn tất việc tạo SSH key trên máy tính của bạn, key này được lưu tại <code>~/.ssh/id_rsa</code>.</p>
<h2 id="Buoc-2-Them-SSH-key-vao-danh-sach-authorized-keys-cua-server"><a href="#Buoc-2-Them-SSH-key-vao-danh-sach-authorized-keys-cua-server" class="headerlink" title="Bước 2: Thêm SSH key vào danh sách authorized keys của server"></a>Bước 2: Thêm SSH key vào danh sách authorized keys của server</h2><p>Tiếp theo, bạn cần phải SSH vào server để thêm SSH key mà bạn vừa tạo vào danh sách authorized keys của server. Bước này dùng để xác thực quyền truy cập vào server cho máy tính của bạn.</p>
<p>Đầu tiên, bạn cần copy public key sử dụng lệnh dưới đây:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>Copy toàn bộ nội dung trả về của lệnh này.</p>
<p>Tiếp theo, kết nối SSH vào server bằng lệnh sau:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh &lt;username&gt;@&lt;ip-address&gt;</span><br></pre></td></tr></table></figure>
<p>Thay <code>username</code> và <code>ip-address</code> thành giá trị tương ứng mà bạn có. Nhập mật khẩu để xác thực.</p>
<p>Sau đó, chèn nội dung của public key vào cuối file <code>~/.ssh/authorized_keys</code> bằng lệnh sau:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;&lt;paste-your-public-key-content-here&gt;&quot; &gt;&gt; ~&#x2F;.ssh&#x2F;authorized_keys</span><br></pre></td></tr></table></figure>
<p>Thay <code>paste-your-public-key-content-here</code> bằng nội dung của public key mà bạn vừa copy.</p>
<p>Như vậy là bạn đã hoàn tất việc xác thực SSH key với server, trong những lần ssh sau, bạn không cần phải cung cấp mật khẩu nữa giúp cho việc ssh vào server trở nên thuận tiện hơn.</p>
<p><strong>Lưu ý</strong>: Nếu ở trong bước 1, bạn sử dụng tên khác để tạo SSH key như <code>id_abc</code> thì bạn cần phải làm thêm 1 bước là thay đổi cấu hình SSH để nó biết được cần phải dùng key nào khi kết nối đến server của bạn.</p>
<p>Trong file <code>~/.ssh/config</code>, bạn cần thêm đoạn dưới đây vào cuối file:</p>
<figure class="highlight plain"><figcaption><span>Chỉ thêm khi file key của bạn khác với mặc định (id_rsa, id_dsa, id_ecdsa, id_ed25519)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host &lt;ip-address&gt;</span><br><span class="line">  HostName &lt;ip-address&gt;</span><br><span class="line">  User &lt;username&gt;</span><br><span class="line">  Port 22</span><br><span class="line">  IdentityFile ~&#x2F;.ssh&#x2F;id_abc</span><br></pre></td></tr></table></figure>

<h2 id="Buoc-3-Thiet-lap-moi-truong-SSH-tren-VS-Code"><a href="#Buoc-3-Thiet-lap-moi-truong-SSH-tren-VS-Code" class="headerlink" title="Bước 3: Thiết lập môi trường SSH trên VS Code"></a>Bước 3: Thiết lập môi trường SSH trên VS Code</h2><p>Sau khi đã có thể kết nối đến server thông qua SSH key, bạn hãy mở VS Code và làm theo các bước sau đây:</p>
<ol>
<li>Nhấn tổ hợp phím <strong>Ctrl + Shift + P</strong> để mở khung <strong>Command Palette</strong>.</li>
<li>Nhập <em>“Remote-SSH: Add New SSH Host”</em> rồi nhấn <strong>Enter</strong>.</li>
<li>Nhập câu lệnh SSH mà bạn sử dụng để SSH đến server: <code>ssh &lt;username&gt;@&lt;ip-address&gt;</code></li>
<li>Nhập đường dẫn đến file config: <code>~/.ssh/config</code></li>
</ol>
<p>VS Code sẽ hiện thống báo rằng server đã được thêm vào. Giờ bạn chọn biểu tượng Remote Explorer ở thanh công cụ bên trái, bạn sẽ thấy địa chỉ ip của server vừa thêm vào. Từ bây giờ, bạn có thể mở 1 folder bất kỳ trên server bằng cách nhấn nút <strong>Connect to Host in New Window</strong> ở kế bên địa chỉ ip của server.</p>
<p>Như vậy là bạn có thể bắt đầu lập trình trên server thông qua VS Code rồi đó.</p>
<p>Một lưu ý nhỏ là khi dùng VS Code trên server thì bạn cần phải cài extension <strong>trên server đó</strong> thì mới có thể dùng được, tức là nếu có extension nào bạn đã cài trên máy rồi thì vẫn phải cài lại trên server.</p>
<p>Happy coding!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blogcuatui.online/2020/12/26/Cau-hinh-VS-Code-de-code-tren-server/" data-id="ckje6sj2n00018cnh1n9kflx9" class="article-share-link">Chia sẻ</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Coding/" rel="tag">Coding</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IDE/" rel="tag">IDE</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/VScode/" rel="tag">VScode</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Open-closed-principle" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/23/Open-closed-principle/" class="article-date">
  <time datetime="2020-08-23T14:28:47.000Z" itemprop="datePublished">2020-08-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/23/Open-closed-principle/">Open-closed principle</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Open-closed principle là 1 trong các nguyên tắc của bộ nguyên tắc lập trình SOLID trong lập trình hướng đối tượng. Đây là 1 nguyên tắc rất quan trọng bởi nó giúp cho code của dự án dễ bảo trì và mở rộng, có thể thích ứng với những thay đổi trong môi trường Agile.</p>
<p>Nguyên văn phát biểu của nguyên tắc này như sau:</p>
<blockquote>
<p>“Các thực thể phần mềm (class, function,…) nên tạo điều kiện cho việc mở rộng, nhưng hạn chế cho việc thay đổi.”</p>
</blockquote>
<p>Có thể hiểu lợi ích của nguyên tắc này thông qua 1 ví dụ như sau, giả sử như bạn là một lập trình viên đang làm cho 1 công ty IT nọ. Bạn vào đó với vai trò phát triển phần mềm cho 1 dự án của 1 team trong công ty. Thật không may, mã nguồn của dự án đó nhiều đến nỗi bạn không kiểm soát được ảnh hưởng của những thành phần trong hệ thống đối với nhau. Nhưng công ty lại đòi hỏi bạn phải hiện thực 1 tính năng mới cho dự án trong 1 thời gian ngắn. Vậy làm cách nào bạn có thể hoàn thành công việc được giao đúng hạn? Bạn sợ rằng nếu bạn hiện thực tính năng mới theo yêu cầu nghĩa là bạn đang tạo ra 1 sự rủi ro khiển cho hệ thống không còn hoạt động giống như trước. Bạn liên tục đặt câu hỏi rằng liệu tính năng mới được thêm vào có làm phá vỡ những tính năng khác hiện có hay không. Nếu chuyện đó thật sự xảy ra thì nó không hẳn hoàn toàn là lỗi của bạn. Cái quan trọng nhất trong chuyện này là cách mà code của dự án đã được thiết kế như thế nào. Nếu code của dự án tuân theo open-closed principle thì bạn có thể hiện thực tính năng mới bằng cách viết thêm code cho dự án, tạo thêm class kế thừa từ class sẵn có trong dự án mà không cần phải thay đổi code có sẵn. Điều này giúp giảm thiểu rủi ro phá vỡ hệ thống đang hoạt động mà vẫn hoàn thành được tiến độ công việc của bạn. Trong khi đó, nếu dự án được thiết kế đi ngược lại open-closed principle thì bạn có thể phải thay đổi code của dự án. Rõ ràng là điều này tiềm ẩn nhiều rủi ro hơn và cũng khó hiện thực hơn trường hợp đầu tiên.</p>
<p>Như vậy, ta đã thấy được lợi ích của việc thiết kế code theo open-closed principle rồi. Vậy code như thế nào mới gọi là tuân theo nguyên tắc đó? Ta hãy tiếp tục tìm hiểu thông qua ví dụ Python dưới đây.</p>
<p>Mình đang làm 1 dự án xây dựng mô hình phân loại spam cho văn bản sử dụng Machine Learning. Để cho dễ hiểu, mình sẽ bỏ qua phần hiện thực của mô hình mà chỉ tập trung vào phần code để sử dụng mô hình mà thôi.</p>
<p>Giả sử như mình đã xây dựng xong 1 mô hình có input là 1 đoạn văn bản và output ra là 1 số hoặc 0 hoặc 1, 0 nghĩa là không phải spam còn 1 nghĩa là spam. Nhưng trước khi đưa nó vào chạy thực tế, mình cần phải đánh giá mô hình này có hoặc động tốt hay không bằng việc cho nó dự đoán 1 tập nhiều văn bản khác nhau và tính tỷ lệ phần trăm mà nó dự đoán đúng. Vậy mình sẽ hiện thực 1 hàm đánh giá mô hình như sau:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Đây là hàm dùng để lấy output của mô hình</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">texts: List[<span class="built_in">str</span>]</span>) -&gt; np.array:</span></span><br><span class="line">    <span class="comment"># Hàm này sẽ dùng mô hình đã được huấn luyện để chạy rồi trả về kết quả của mô hình</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate_spam_model</span>(<span class="params">texts: List[<span class="built_in">str</span>], truth_labels: np.array</span>) -&gt; float:</span></span><br><span class="line">    predicted_labels = predict(texts)</span><br><span class="line">    num_correct_predictions = np.<span class="built_in">sum</span>(predicted_labels == truth_labels) <span class="comment"># Tính số lần mà mô hình dự đoán đúng</span></span><br><span class="line">    num_total_predictions = <span class="built_in">len</span>(texts) <span class="comment"># Tổng số văn bản mà mô hình dự đoán.</span></span><br><span class="line">    accuracy = num_correct_predictions / num_total_predictions <span class="comment"># Tính accuracy của mô hình</span></span><br><span class="line">    <span class="keyword">return</span> accuracy</span><br></pre></td></tr></table></figure>

<p>Khi chạy hàm này, mình nhận thấy kết quả đánh giá của mô hình không đạt yêu cầu đề ra nên mình quyết định thử dùng 1 phương pháp mới để cải thiện độ chính xác của mô hình. Sau khi hiện thực lại xong, mình nhận thấy hàm <code>predict</code> không thể chạy được mô hình mới vì bạn đã dùng thư viện khác để hiện thực nó. Bạn thay đổi code của mình thành như sau:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">texts: List[<span class="built_in">str</span>], model_name: <span class="built_in">str</span></span>) -&gt; np.array:</span></span><br><span class="line">    <span class="keyword">if</span> model_name == <span class="string">&#x27;v1&#x27;</span>:</span><br><span class="line">        <span class="comment"># Chạy mô hình đầu tiên</span></span><br><span class="line">    <span class="keyword">elif</span> model_name == <span class="string">&#x27;v2&#x27;</span>:</span><br><span class="line">        <span class="comment"># Chạy mô hình thứ hai</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;No such model.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate_spam_model</span>(<span class="params">texts: List[<span class="built_in">str</span>], truth_labels: np.array, model_name: <span class="built_in">str</span></span>) -&gt; float:</span></span><br><span class="line">    predicted_labels = predict(texts, model_name)</span><br><span class="line">    num_correct_predictions = np.<span class="built_in">sum</span>(predicted_labels == truth_labels) <span class="comment"># Tính số lần mà mô hình dự đoán đúng</span></span><br><span class="line">    num_total_predictions = <span class="built_in">len</span>(texts) <span class="comment"># Tổng số văn bản mà mô hình dự đoán.</span></span><br><span class="line">    accuracy = num_correct_predictions / num_total_predictions <span class="comment"># Tính accuracy của mô hình</span></span><br><span class="line">    <span class="keyword">return</span> accuracy</span><br></pre></td></tr></table></figure>

<p>Ở đây ta có 2 vấn đề:</p>
<ol>
<li>Việc thêm code vào hàm <code>predict</code> làm tăng rủi ro sinh ra bug cho hàm này. Nếu như mình chỉ có 2 hoặc 3 mô hình thì không thành vấn đề. Nhưng giả sử khi mình có tới hàng chục mô hình khác nhau thì đồng nghĩa với việc hàm này sẽ vô cùng dài và khó đọc. Khi đó thì việc kiểm tra lỗi sẽ trở nên khó khăn hơn.</li>
<li>Việc thay đổi signature của hàm <code>predict</code> khiến cho những hàm sử dụng nó cũng thay đổi theo. Trong trường hợp này thì chỉ có 1 mình hàm <code>evaluate_spam_model</code> là phải thay đổi. Nhưng nếu như mình có hàm khác sử dụng hàm <code>evaluate_spam_model</code> thì sao? Ví dụ như hàm <code>report_spam_performance</code> sử dụng hàm <code>evaluate_spam_model</code> để chạy ra kết quả và output ra 1 report để mình xem. Như vậy, việc thay đổi signature của 1 hàm có thể dẫn đến việc thay đổi signature của toàn bộ hàm trực tiếp hoặc gián tiếp sử dụng nó.</li>
</ol>
<p>Rõ ràng là đoạn code trên không tuân theo open-closed principle. Vậy code tuân theo nguyên tắc này sẽ trông như thế nào? Hãy xem đoạn code dưới đây:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpamStrategy</span>(<span class="params">ABC</span>):</span> <span class="comment"># Khai báo class kế thừa Abstract Base Classes. Link: https://docs.python.org/3/library/abc.html#abc.ABC</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">self, texts: List[<span class="built_in">str</span>]</span>) -&gt; np.array:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpamV1Strategy</span>(<span class="params">SpamStrategy</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">self, text: List[<span class="built_in">str</span>]</span>) -&gt; np.array:</span></span><br><span class="line">        <span class="comment"># Chạy mô hình thứ nhất</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpamV2Strategy</span>(<span class="params">SpamStrategy</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">self, text: List[<span class="built_in">str</span>]</span>) -&gt; np.array:</span></span><br><span class="line">        <span class="comment"># Chạy mô hình thứ hai</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate_spam_model</span>(<span class="params">texts: List[<span class="built_in">str</span>], truth_labels: np.array, strategy: SpamStrategy</span>):</span></span><br><span class="line">    predicted_labels = strategy.predict(texts, model_name)</span><br><span class="line">    num_correct_predictions = np.<span class="built_in">sum</span>(predicted_labels == truth_labels) <span class="comment"># Tính số lần mà mô hình dự đoán đúng</span></span><br><span class="line">    num_total_predictions = <span class="built_in">len</span>(texts) <span class="comment"># Tổng số văn bản mà mô hình dự đoán.</span></span><br><span class="line">    accuracy = num_correct_predictions / num_total_predictions <span class="comment"># Tính accuracy của mô hình</span></span><br><span class="line">    <span class="keyword">return</span> accuracy</span><br></pre></td></tr></table></figure>

<p>Ở đây, mình khai báo 1 abstract class <code>SpamStrategy</code> có khai báo 1 hàm abstract là <code>predict</code>. Mỗi lần hiện thực 1 mô hình spam mới thì mình sẽ tạo thêm 1 class mới kế thừa từ class này rồi chạy hàm <code>evaluate_spam_model</code> bằng việc thay đổi tham số strategy. Như vậy, mỗi lần mình hiện thực thêm 1 mô hình mới thì đoạn code của những mô hình cũ (những class kế thừa từ <code>SpamStrategy</code>) không bị thay đổi. Nếu như mình nhận thấy mô hình mới không được tốt như mô hình cũ thì mình vẫn có thể dễ dàng chạy lại mô hình cũ chỉ bằng việc thay đổi tham số của hàm <code>evaluate_spam_model</code> mà thôi!</p>
<p>Thông qua ví dụ trên, chúng ta thấy được tầm quan trọng của việc thiết kế code theo open-closed principle. Đối với những dự án nhỏ, nguyên tắc này đôi khi là không cần thiết bởi nó khiến cho code trở nên dài dòng hơn. Nhưng khi dự án phình to ra với vô số hàm và class được thêm vào thì ta mới thấy rõ được tầm quan trọng của nguyên tác này.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blogcuatui.online/2020/08/23/Open-closed-principle/" data-id="ckje6sj2r00048cnh1qac6s9n" class="article-share-link">Chia sẻ</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OOP/" rel="tag">OOP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SOLID/" rel="tag">SOLID</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Software-Engineering/" rel="tag">Software Engineering</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-su-doi-lap-giua-object-va-data-structure" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/09/su-doi-lap-giua-object-va-data-structure/" class="article-date">
  <time datetime="2020-08-09T16:13:43.000Z" itemprop="datePublished">2020-08-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/09/su-doi-lap-giua-object-va-data-structure/">Sự đối lập giữa Object và Data Structure</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Bài viết này là kiến thức mình học được khi đọc cuốn <em>Clean Code: A Handbook of Agile Software Craftsmanship</em>, mình muốn thông qua bài viết này có thể chia sẻ hiểu biết của mình với mọi người cũng như tự giúp bản thân nắm vững hơn những gì đã đọc được.</p>
<p>Trong lập trình hướng đối tượng, 2 khái niệm object và data structure có sự đối lập nhau rõ ràng mặc dù nghe thì chúng có vẻ hơi hơi giống nhau. Trong bài viết này, mình sẽ tìm hiểu và phân tích sự đối lập này thông qua 1 ví dụ thực tế.</p>
<h2 id="Su-khac-nhau-giua-Object-va-Data-Structure"><a href="#Su-khac-nhau-giua-Object-va-Data-Structure" class="headerlink" title="Sự khác nhau giữa Object và Data Structure"></a>Sự khác nhau giữa Object và Data Structure</h2><p>Object đóng gói toàn bộ dữ liệu của nó bên trong 1 class và chỉ cung cấp ra bên ngoài một hoặc nhiều hàm để người dùng gọi. Như vậy, chỉ có các hàm bên trong 1 class mới có thể quản lý dữ liệu của class đó. Ngược lại, data structure để phơi bày dữ liệu của nó và không có bất kỳ hàm nào có ý nghĩa.</p>
<p>Ta có thể thấy trong đoạn văn trên, object và data structure hoàn toàn đối lập nhau. Một bên thì giấu dữ liệu và phơi bày hàm, còn một bên thì phơi bày dữ liệu và không có hàm (coi như giấu).</p>
<h2 id="Vi-du"><a href="#Vi-du" class="headerlink" title="Ví dụ"></a>Ví dụ</h2><p>Mình hãy cùng xem xét 1 ví dụ như sau:<br>Dưới đây là 1 đoạn code viết theo hướng data structure. Mỗi shape chỉ đơn giản là 1 tập các thuộc tính riêng biệt của mỗi dạng hình học. Class Geometry có nhiệm vụ tính toán các giá trị chẳng hạn như diện tích dựa trên 3 shape này.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Point topLeft;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> side;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Point topLeft;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> height;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Point center;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Geometry</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">(Object shape)</span> <span class="keyword">throws</span> NoSuchShapeException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (shape <span class="keyword">instanceof</span> Square) &#123;</span><br><span class="line">            Square s = (Square)shape;</span><br><span class="line">            <span class="keyword">return</span> s.side * s.side;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (shape <span class="keyword">instanceof</span> Rectangle) &#123;</span><br><span class="line">            Rectangle r = (Rectangle)shape;</span><br><span class="line">            <span class="keyword">return</span> r.height * r.width;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (shape <span class="keyword">instanceof</span> Circle) &#123;</span><br><span class="line">            Circle c = (Circle)shape;</span><br><span class="line">            <span class="keyword">return</span> Math.PI * c.radius * c.radius;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchShapeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Còn dưới đây là 1 đoạn code được viết theo hướng OOP, mỗi shape bắt buộc phải thừa kế từ class Shape và tự hiện thực các hàm của Shape.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Point topLeft;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> side;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> side * side;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Point topLeft;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height * width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Point center;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Giả sử như chúng ta muốn thêm 1 shape mới vào code (Triangle chẳng hạn), đối với đoạn code đầu tiên (code theo data structure) thì ta cần khai báo thêm 1 data structure mới tên là Triangle và thay đổi toàn bộ hàm có trong class Geometry (trong trường hợp này chỉ có 1 hàm area). Tuy nhiên, trong 1 trường hợp khác, khi ta chỉ muốn thêm 1 hàm mới để tính chu vi của shape, ta chỉ cần khai báo 1 hàm tên là perimeter trong class Geometry và mọi thay đổi chỉ gói gọn trong hàm này mà thôi.<br>Bây giờ mình sẽ dùng đoạn code thứ hai (sử dụng OOP) để áp dụng vào trường hợp trên. Việc thêm 1 shape mới trở nên dễ dàng hơn rất nhiều so với sử dụng data structure, chỉ cần tạo 1 class mới tên là Triangle và hiện thực các hàm cần thiết của class Shape mà không làm ảnh hưởng đến các Shape còn lại. Trong khi đó, nếu thêm hàm perimeter vào class Shape thì đòi hỏi ta phải thay đổi toàn bộ code của mọi class thừa kế từ Shape.</p>
<p>Như vậy có thể thấy rằng:<br><strong>Đối với lập trình sử dụng data structure, việc thêm 1 hàm mới trở nên dễ dàng mà không cần thay đổi code trong những data structure khác nhưng lại khó để thêm 1 data structure mới vì phải thay đổi toàn bộ hàm có sẵn. Ở chiều ngược lại, lập trình theo hướng đối tượng khiến cho việc thêm 1 class mới dễ dàng mà không cần thay đổi những class khác nhưng lại khó để thêm 1 hàm mới vì toàn bộ class khác phải thay đổi theo.</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blogcuatui.online/2020/08/09/su-doi-lap-giua-object-va-data-structure/" data-id="ckje6sj30000y8cnh3zk4dkw5" class="article-share-link">Chia sẻ</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-structure/" rel="tag">Data structure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OOP/" rel="tag">OOP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Software-Engineering/" rel="tag">Software Engineering</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Coding/" rel="tag">Coding</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-structure/" rel="tag">Data structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDE/" rel="tag">IDE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OOP/" rel="tag">OOP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SOLID/" rel="tag">SOLID</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Software-Engineering/" rel="tag">Software Engineering</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VScode/" rel="tag">VScode</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Coding/" style="font-size: 20px;">Coding</a> <a href="/tags/Data-structure/" style="font-size: 10px;">Data structure</a> <a href="/tags/IDE/" style="font-size: 10px;">IDE</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Kafka/" style="font-size: 10px;">Kafka</a> <a href="/tags/OOP/" style="font-size: 20px;">OOP</a> <a href="/tags/Python/" style="font-size: 20px;">Python</a> <a href="/tags/SOLID/" style="font-size: 10px;">SOLID</a> <a href="/tags/Software-Engineering/" style="font-size: 20px;">Software Engineering</a> <a href="/tags/VScode/" style="font-size: 10px;">VScode</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">tháng 1 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">tháng 12 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">tháng 8 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Bài viết gần đây</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/01/Lam-quen-voi-Kafka-Phan-1-Chat-voi-nhau-tren-console/">Làm quen với Kafka: Phần 1 - Chat với nhau trên console</a>
          </li>
        
          <li>
            <a href="/2020/12/26/Cau-hinh-VS-Code-de-code-tren-server/">Cấu hình VS Code để lập trình trên server bằng Remote - SSH</a>
          </li>
        
          <li>
            <a href="/2020/08/23/Open-closed-principle/">Open-closed principle</a>
          </li>
        
          <li>
            <a href="/2020/08/09/su-doi-lap-giua-object-va-data-structure/">Sự đối lập giữa Object và Data Structure</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Vũ Đức Duy<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Trang chủ</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>